<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python OOP Structure Visualizer - v3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Left Panel - Code Input */
        .input-panel {
            width: 380px;
            background: #fff;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .input-panel h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-tabs-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .file-tabs {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            flex: 1;
        }

        .file-tab {
            padding: 6px 12px;
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            color: #7f8c8d;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .file-tab:hover {
            background: #d5dbdb;
        }

        .file-tab.active {
            background: #3498db;
            border-color: #2980b9;
            color: white;
        }

        .file-tab .remove {
            margin-left: 6px;
            opacity: 0.6;
        }

        .file-tab .remove:hover {
            opacity: 1;
        }

        .add-file-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px dashed #bdc3c7;
            color: #95a5a6;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .add-file-btn:hover {
            border-color: #3498db;
            color: #3498db;
        }

        .clear-all-btn {
            padding: 6px 10px;
            background: #e74c3c;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .clear-all-btn:hover {
            background: #c0392b;
        }

        .project-name-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .project-name-input {
            flex: 1;
            padding: 8px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #2c3e50;
            font-weight: 600;
        }

        .project-name-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .code-input {
            flex: 1;
            background: #2c3e50;
            border: 1px solid #34495e;
            border-radius: 6px;
            padding: 12px;
            color: #ecf0f1;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            resize: none;
            line-height: 1.5;
        }

        .code-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .parse-btn {
            flex: 1;
            padding: 10px 16px;
            background: #27ae60;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .parse-btn:hover {
            background: #219a52;
        }

        .load-example-btn {
            padding: 10px 16px;
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            color: #7f8c8d;
            cursor: pointer;
            transition: all 0.2s;
        }

        .load-example-btn:hover {
            background: #d5dbdb;
            color: #2c3e50;
        }

        /* Right Panel - Visualization */
        .viz-panel {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
            background-image: 
                linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .viz-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .viz-controls button {
            padding: 6px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .viz-controls button:hover {
            background: #f8f9fa;
            border-color: #3498db;
            color: #3498db;
        }

        #visualization {
            width: 100%;
            height: 100%;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(255,255,255,0.95);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .legend h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.75rem;
            color: #666;
        }

        .legend-shape {
            width: 20px;
            height: 14px;
            border-radius: 2px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            border-radius: 6px;
            padding: 10px 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 320px;
            z-index: 1000;
            color: #ecf0f1;
        }

        .tooltip h4 {
            color: #3498db;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .tooltip p {
            font-size: 0.8rem;
            margin: 2px 0;
        }

        .tooltip code {
            background: rgba(0,0,0,0.3);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
        }

        .tooltip .body-list {
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid #3498db;
            font-family: 'Fira Code', monospace;
            font-size: 0.7rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .tooltip .body-list div {
            padding: 2px 0;
            color: #a8dadc;
        }

        .instructions {
            margin-top: 12px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #7f8c8d;
            line-height: 1.5;
        }

        .instructions strong {
            color: #2c3e50;
        }

        /* Loop node special styling */
        .loop-detail-text {
            font-family: 'Fira Code', monospace;
            font-size: 9px;
            fill: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-panel">
            <h2>üêç Python Structure Visualizer</h2>
            
            <div class="project-name-row">
                <input type="text" class="project-name-input" id="projectName" placeholder="Project Name" value="My Project">
            </div>
            
            <div class="file-tabs-container">
                <div class="file-tabs" id="fileTabs"></div>
                <button class="clear-all-btn" id="clearAllBtn">Clear All</button>
            </div>
            
            <textarea class="code-input" id="codeInput" placeholder="Paste your Python code here..."></textarea>
            
            <div class="btn-row">
                <button class="parse-btn" id="parseBtn">‚ñ∂ Generate Diagram</button>
                <button class="load-example-btn" id="loadExampleBtn">Load Example</button>
            </div>
            
            <div class="instructions">
                <strong>Enhanced Loop Visualization:</strong><br>
                ‚Ä¢ For loops show: iterator, iterable, body<br>
                ‚Ä¢ While loops show: condition, body<br>
                ‚Ä¢ Hover over loops to see details
            </div>
        </div>
        
        <div class="viz-panel">
            <div class="viz-controls">
                <button id="zoomIn">+</button>
                <button id="zoomOut">‚àí</button>
                <button id="resetView">Reset</button>
                <button id="exportSVG">Export SVG</button>
            </div>
            
            <svg id="visualization"></svg>
            
            <div class="legend">
                <h4>Legend</h4>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #dae8fc; border: 1px solid #6c8ebf;"></div>
                    <span>Project</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #fff2cc; border: 1px solid #d6b656;"></div>
                    <span>Module</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #d5e8d4; border: 1px solid #82b366; border-radius: 50%;"></div>
                    <span>Class</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #f8cecc; border: 1px solid #b85450;"></div>
                    <span>Method / Function</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #e1d5e7; border: 1px solid #9673a6;"></div>
                    <span>Variable</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #f5f5f5; border: 1px solid #666;"></div>
                    <span>Data / List</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #fff2cc; border: 1px solid #d6b656;"></div>
                    <span>Loop (For/While)</span>
                </div>
            </div>
            
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // =============================================
        // Configuration
        // =============================================
        const CONFIG = {
            project: { w: 160, h: 45 },
            module: { w: 140, h: 35, gapX: 280 },
            class: { w: 140, h: 45 },
            method: { w: 130, h: 35, offsetX: 100, gapY: 15 },
            variable: { w: 120, h: 24, offsetX: 90, gapY: 8 },
            data: { w: 110, h: 40, gapY: 15 },
            loop: { w: 160, h: 50, offsetX: 100, gapY: 15 },
            loopBody: { w: 140, h: 22, offsetX: 40, gapY: 6 },
            instantiation: { w: 180, h: 30, gapY: 15 },
            verticalGap: 20,
            moduleStartY: 120,
            colors: {
                project: { fill: '#dae8fc', stroke: '#6c8ebf' },
                module: { fill: '#fff2cc', stroke: '#d6b656' },
                class: { fill: '#d5e8d4', stroke: '#82b366' },
                method: { fill: '#f8cecc', stroke: '#b85450' },
                variable: { fill: '#e1d5e7', stroke: '#9673a6' },
                data: { fill: '#f5f5f5', stroke: '#666666' },
                loop: { fill: '#fff2cc', stroke: '#d6b656' },
                loopBody: { fill: '#fef9e7', stroke: '#d4ac0d' },
                instantiation: { fill: '#fff2cc', stroke: '#d6b656' },
                link: '#666'
            }
        };

        // =============================================
        // File Management
        // =============================================
        let files = [{ name: 'main.py', code: '' }];
        let activeFileIndex = 0;

        const fileTabs = document.getElementById('fileTabs');
        const codeInput = document.getElementById('codeInput');

        function renderFileTabs() {
            fileTabs.innerHTML = '';
            files.forEach((file, index) => {
                const tab = document.createElement('button');
                tab.className = `file-tab ${index === activeFileIndex ? 'active' : ''}`;
                tab.dataset.file = index;
                tab.innerHTML = `${file.name}<span class="remove" data-remove="${index}">√ó</span>`;
                fileTabs.appendChild(tab);
            });
            
            const addBtn = document.createElement('button');
            addBtn.className = 'add-file-btn';
            addBtn.id = 'addFileBtn';
            addBtn.textContent = '+ Add';
            fileTabs.appendChild(addBtn);
        }

        fileTabs.addEventListener('click', (e) => {
            if (e.target.dataset.file !== undefined) {
                files[activeFileIndex].code = codeInput.value;
                activeFileIndex = parseInt(e.target.dataset.file);
                codeInput.value = files[activeFileIndex].code;
                renderFileTabs();
            } else if (e.target.dataset.remove !== undefined) {
                e.stopPropagation();
                const removeIndex = parseInt(e.target.dataset.remove);
                if (files.length > 1) {
                    files.splice(removeIndex, 1);
                    if (activeFileIndex >= files.length) activeFileIndex = files.length - 1;
                    codeInput.value = files[activeFileIndex].code;
                    renderFileTabs();
                }
            } else if (e.target.id === 'addFileBtn') {
                files[activeFileIndex].code = codeInput.value;
                const newName = prompt('Enter file name (e.g., utils.py):', 'new_file.py');
                if (newName) {
                    files.push({ name: newName, code: '' });
                    activeFileIndex = files.length - 1;
                    codeInput.value = '';
                    renderFileTabs();
                }
            }
        });

        // Clear All Button
        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (confirm('Clear all files and start fresh?')) {
                files = [{ name: 'main.py', code: '' }];
                activeFileIndex = 0;
                codeInput.value = '';
                document.getElementById('projectName').value = 'My Project';
                renderFileTabs();
                initVisualization(); // Clear the diagram too
            }
        });

        // =============================================
        // Enhanced Python Parser with Loop Details
        // =============================================
        function parsePythonCode(code, moduleName) {
            const result = {
                name: moduleName,
                elements: []
            };

            const lines = code.split('\n');
            let currentClass = null;
            let currentMethod = null;
            let classIndent = -1;
            let methodIndent = -1;
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                const trimmed = line.trim();
                const indent = line.search(/\S/);
                
                if (indent === -1 || trimmed.startsWith('#')) {
                    i++;
                    continue;
                }

                // Check if we've exited a class
                if (currentClass && indent <= classIndent && trimmed) {
                    currentClass = null;
                    currentMethod = null;
                    classIndent = -1;
                    methodIndent = -1;
                }

                // Check if we've exited a method
                if (currentMethod && indent <= methodIndent && !trimmed.startsWith('def ')) {
                    currentMethod = null;
                    methodIndent = -1;
                }

                // Skip imports
                if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {
                    i++;
                    continue;
                }

                // Parse class definitions
                const classMatch = trimmed.match(/^class\s+(\w+)(?:\(.*\))?:/);
                if (classMatch) {
                    currentClass = {
                        type: 'class',
                        name: classMatch[1],
                        methods: []
                    };
                    result.elements.push(currentClass);
                    classIndent = indent;
                    currentMethod = null;
                    methodIndent = -1;
                    i++;
                    continue;
                }

                // Parse method definitions (inside class)
                if (currentClass) {
                    const methodMatch = trimmed.match(/^def\s+(\w+)\s*\(/);
                    if (methodMatch) {
                        currentMethod = {
                            type: 'method',
                            name: methodMatch[1],
                            variables: []
                        };
                        currentClass.methods.push(currentMethod);
                        methodIndent = indent;
                        i++;
                        continue;
                    }

                    // Parse self.x assignments
                    if (currentMethod) {
                        const selfMatch = trimmed.match(/self\.(\w+)\s*=/);
                        if (selfMatch) {
                            const varName = `self.${selfMatch[1]}`;
                            if (!currentMethod.variables.includes(varName)) {
                                currentMethod.variables.push(varName);
                            }
                            i++;
                            continue;
                        }

                        // Parse local variables
                        const varMatch = trimmed.match(/^(\w+)\s*=\s*(?!.*def\s)/);
                        if (varMatch && !['self', '_', 'True', 'False', 'None'].includes(varMatch[1])) {
                            if (!currentMethod.variables.includes(varMatch[1])) {
                                currentMethod.variables.push(varMatch[1]);
                            }
                        }
                    }
                    i++;
                    continue;
                }

                // Parse data structures at module level
                const dictMatch = trimmed.match(/^(\w+)\s*=\s*[\[{]/);
                if (dictMatch) {
                    result.elements.push({
                        type: 'data',
                        name: dictMatch[1],
                        isDict: trimmed.includes('{')
                    });
                    i++;
                    continue;
                }

                // Parse simple variable assignments at module level
                const simpleVarMatch = trimmed.match(/^(\w+)\s*=\s*(.+)$/);
                if (simpleVarMatch && !trimmed.includes('(') && !currentClass) {
                    const varName = simpleVarMatch[1];
                    const varValue = simpleVarMatch[2].trim();
                    if (!['True', 'False', 'None'].includes(varName)) {
                        result.elements.push({
                            type: 'variable',
                            name: varName,
                            value: varValue
                        });
                        i++;
                        continue;
                    }
                }

                // Parse FOR loops at module level with body extraction
                if (trimmed.startsWith('for ') && !currentClass) {
                    const forMatch = trimmed.match(/^for\s+(\w+)\s+in\s+(.+):/);
                    if (forMatch) {
                        const loopIndent = indent;
                        const bodyStatements = [];
                        
                        // Extract loop body
                        let j = i + 1;
                        while (j < lines.length) {
                            const bodyLine = lines[j];
                            const bodyTrimmed = bodyLine.trim();
                            const bodyIndent = bodyLine.search(/\S/);
                            
                            if (bodyIndent === -1) {
                                j++;
                                continue;
                            }
                            
                            if (bodyIndent <= loopIndent) {
                                break;
                            }
                            
                            if (!bodyTrimmed.startsWith('#')) {
                                bodyStatements.push(bodyTrimmed);
                            }
                            j++;
                        }
                        
                        result.elements.push({
                            type: 'forLoop',
                            iterator: forMatch[1],
                            iterable: forMatch[2],
                            body: bodyStatements,
                            fullCondition: `${forMatch[1]} in ${forMatch[2]}`
                        });
                        
                        i = j;
                        continue;
                    }
                }

                // Parse WHILE loops at module level with body extraction
                if (trimmed.startsWith('while ') && !currentClass) {
                    const whileMatch = trimmed.match(/^while\s+(.+):/);
                    if (whileMatch) {
                        const loopIndent = indent;
                        const bodyStatements = [];
                        
                        // Extract loop body
                        let j = i + 1;
                        while (j < lines.length) {
                            const bodyLine = lines[j];
                            const bodyTrimmed = bodyLine.trim();
                            const bodyIndent = bodyLine.search(/\S/);
                            
                            if (bodyIndent === -1) {
                                j++;
                                continue;
                            }
                            
                            if (bodyIndent <= loopIndent) {
                                break;
                            }
                            
                            if (!bodyTrimmed.startsWith('#')) {
                                bodyStatements.push(bodyTrimmed);
                            }
                            j++;
                        }
                        
                        result.elements.push({
                            type: 'whileLoop',
                            condition: whileMatch[1],
                            body: bodyStatements
                        });
                        
                        i = j;
                        continue;
                    }
                }

                // Parse instantiations at module level
                const instMatch = trimmed.match(/^(\w+)\s*=\s*(\w+)\s*\((.*)?\)/);
                if (instMatch && !currentClass) {
                    const className = instMatch[2];
                    if (className[0] === className[0].toUpperCase() && className[0] !== className[0].toLowerCase()) {
                        result.elements.push({
                            type: 'instantiation',
                            variable: instMatch[1],
                            className: className,
                            args: instMatch[3] || ''
                        });
                        i++;
                        continue;
                    }
                }

                // Parse standalone function definitions
                const funcMatch = trimmed.match(/^def\s+(\w+)\s*\((.*)?\):/);
                if (funcMatch && !currentClass) {
                    const funcIndent = indent;
                    const funcBody = [];
                    
                    // Extract function body
                    let j = i + 1;
                    while (j < lines.length) {
                        const bodyLine = lines[j];
                        const bodyTrimmed = bodyLine.trim();
                        const bodyIndent = bodyLine.search(/\S/);
                        
                        if (bodyIndent === -1) {
                            j++;
                            continue;
                        }
                        
                        if (bodyIndent <= funcIndent) {
                            break;
                        }
                        
                        if (!bodyTrimmed.startsWith('#')) {
                            // Check for variable assignments
                            const localVar = bodyTrimmed.match(/^(\w+)\s*=\s*/);
                            if (localVar && !['return', 'if', 'else', 'elif', 'for', 'while'].includes(localVar[1])) {
                                funcBody.push(localVar[1]);
                            }
                        }
                        j++;
                    }
                    
                    result.elements.push({
                        type: 'function',
                        name: funcMatch[1],
                        params: funcMatch[2] || '',
                        variables: funcBody
                    });
                    
                    i = j;
                    continue;
                }

                i++;
            }

            return result;
        }

        // =============================================
        // D3 Visualization with Rounded Arrows
        // =============================================
        const svg = d3.select('#visualization');
        const tooltip = d3.select('#tooltip');
        let g;
        let zoom;

        function initVisualization() {
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;

            svg.attr('width', width).attr('height', height);
            svg.selectAll('*').remove();

            const defs = svg.append('defs');
            
            // Rounded arrow marker
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '-0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 5)
                .attr('markerHeight', 5)
                .append('path')
                .attr('d', 'M 0,-3 Q 5,0 0,3 L 8,0 Z')
                .attr('fill', CONFIG.colors.link);

            g = svg.append('g');

            zoom = d3.zoom()
                .scaleExtent([0.2, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);
        }

        // Create rounded path between two points
        function createRoundedPath(x1, y1, x2, y2, type) {
            const radius = 8; // Corner radius
            
            if (type === 'centered') {
                // Vertical path with potential horizontal offset
                if (Math.abs(x1 - x2) < 5) {
                    // Straight down
                    return `M ${x1} ${y1} L ${x1} ${y2}`;
                } else {
                    // Down, across, down with rounded corners
                    const midY = (y1 + y2) / 2;
                    const dir = x2 > x1 ? 1 : -1;
                    
                    return `M ${x1} ${y1} 
                            L ${x1} ${midY - radius}
                            Q ${x1} ${midY} ${x1 + dir * radius} ${midY}
                            L ${x2 - dir * radius} ${midY}
                            Q ${x2} ${midY} ${x2} ${midY + radius}
                            L ${x2} ${y2}`;
                }
            } else {
                // Offset path: down, right, then to target
                const dropY = y1 + 15;
                const approachX = x2 - 20;
                
                return `M ${x1} ${y1}
                        L ${x1} ${dropY - radius}
                        Q ${x1} ${dropY} ${x1 + radius} ${dropY}
                        L ${approachX - radius} ${dropY}
                        Q ${approachX} ${dropY} ${approachX} ${dropY + radius}
                        L ${approachX} ${y2 - radius}
                        Q ${approachX} ${y2} ${approachX + radius} ${y2}
                        L ${x2} ${y2}`;
            }
        }

        function renderSequentialFlow(projectName, modules) {
            initVisualization();

            const width = svg.node().parentElement.clientWidth;
            const nodes = [];
            const links = [];

            // Calculate column widths
            const columnWidths = [];
            modules.forEach((mod) => {
                let maxWidth = CONFIG.module.w;
                mod.elements.forEach(el => {
                    if (el.type === 'class') {
                        const varWidth = CONFIG.method.offsetX + CONFIG.variable.offsetX + CONFIG.variable.w;
                        maxWidth = Math.max(maxWidth, varWidth + 40);
                    }
                    if (el.type === 'forLoop' || el.type === 'whileLoop') {
                        const loopWidth = CONFIG.loop.offsetX + CONFIG.loop.w + CONFIG.loopBody.offsetX + CONFIG.loopBody.w;
                        maxWidth = Math.max(maxWidth, loopWidth + 20);
                    }
                    if (el.type === 'instantiation') {
                        maxWidth = Math.max(maxWidth, CONFIG.instantiation.w + 20);
                    }
                });
                columnWidths.push(maxWidth);
            });

            // Calculate column X positions
            const columnX = [];
            let currentX = 60;
            columnWidths.forEach((w) => {
                columnX.push(currentX);
                currentX += w + 50;
            });
            const totalWidth = currentX;

            // Project node
            const projectNode = {
                id: 'project',
                type: 'project',
                name: projectName,
                x: 60 + (totalWidth - 60) / 2 - CONFIG.project.w / 2,
                y: 30,
                w: CONFIG.project.w,
                h: CONFIG.project.h
            };
            nodes.push(projectNode);

            // Process each module
            modules.forEach((mod, modIdx) => {
                const modX = columnX[modIdx];
                let curY = CONFIG.moduleStartY;

                // Module node
                const moduleNode = {
                    id: `mod_${modIdx}`,
                    type: 'module',
                    name: mod.name.replace('.py', ''),
                    x: modX,
                    y: curY,
                    w: CONFIG.module.w,
                    h: CONFIG.module.h
                };
                nodes.push(moduleNode);
                links.push({ source: projectNode.id, target: moduleNode.id, type: 'centered' });

                curY += CONFIG.module.h + CONFIG.verticalGap;
                let lastCenteredNode = moduleNode;

                // Process elements
                mod.elements.forEach((el, elIdx) => {
                    if (el.type === 'data') {
                        const dataNode = {
                            id: `mod_${modIdx}_data_${elIdx}`,
                            type: 'data',
                            name: el.name,
                            x: modX + (CONFIG.module.w - CONFIG.data.w) / 2,
                            y: curY,
                            w: CONFIG.data.w,
                            h: CONFIG.data.h,
                            isDict: el.isDict
                        };
                        nodes.push(dataNode);
                        links.push({ source: lastCenteredNode.id, target: dataNode.id, type: 'centered' });
                        lastCenteredNode = dataNode;
                        curY += CONFIG.data.h + CONFIG.data.gapY;
                    }
                    else if (el.type === 'variable') {
                        const varNode = {
                            id: `mod_${modIdx}_var_${elIdx}`,
                            type: 'variable',
                            name: `${el.name} = ${el.value}`,
                            x: modX + (CONFIG.module.w - CONFIG.variable.w) / 2,
                            y: curY,
                            w: CONFIG.variable.w + 20,
                            h: CONFIG.variable.h
                        };
                        nodes.push(varNode);
                        links.push({ source: lastCenteredNode.id, target: varNode.id, type: 'centered' });
                        lastCenteredNode = varNode;
                        curY += CONFIG.variable.h + CONFIG.variable.gapY + 5;
                    }
                    else if (el.type === 'class') {
                        const classNode = {
                            id: `mod_${modIdx}_class_${elIdx}`,
                            type: 'class',
                            name: el.name,
                            x: modX + (CONFIG.module.w - CONFIG.class.w) / 2,
                            y: curY,
                            w: CONFIG.class.w,
                            h: CONFIG.class.h
                        };
                        nodes.push(classNode);
                        links.push({ source: lastCenteredNode.id, target: classNode.id, type: 'centered' });

                        let methodY = curY + CONFIG.class.h + CONFIG.method.gapY;
                        const methodX = modX + CONFIG.method.offsetX;

                        el.methods.forEach((method, mIdx) => {
                            const methodNode = {
                                id: `mod_${modIdx}_class_${elIdx}_method_${mIdx}`,
                                type: 'method',
                                name: method.name,
                                x: methodX,
                                y: methodY,
                                w: CONFIG.method.w,
                                h: CONFIG.method.h
                            };
                            nodes.push(methodNode);
                            links.push({ source: classNode.id, target: methodNode.id, type: 'offset' });

                            let varY = methodY + CONFIG.method.h + CONFIG.variable.gapY;
                            const varX = methodX + CONFIG.variable.offsetX;

                            method.variables.forEach((varName, vIdx) => {
                                const varNode = {
                                    id: `mod_${modIdx}_class_${elIdx}_method_${mIdx}_var_${vIdx}`,
                                    type: 'variable',
                                    name: varName,
                                    x: varX,
                                    y: varY,
                                    w: CONFIG.variable.w,
                                    h: CONFIG.variable.h
                                };
                                nodes.push(varNode);
                                links.push({ source: methodNode.id, target: varNode.id, type: 'offset' });
                                varY += CONFIG.variable.h + CONFIG.variable.gapY;
                            });

                            methodY = method.variables.length > 0 ? varY + CONFIG.method.gapY : methodY + CONFIG.method.h + CONFIG.method.gapY + 20;
                        });

                        curY = methodY + 10;
                        lastCenteredNode = classNode;
                    }
                    else if (el.type === 'function') {
                        const funcNode = {
                            id: `mod_${modIdx}_func_${elIdx}`,
                            type: 'method',
                            name: el.name,
                            params: el.params,
                            x: modX + (CONFIG.module.w - CONFIG.method.w) / 2,
                            y: curY,
                            w: CONFIG.method.w,
                            h: CONFIG.method.h
                        };
                        nodes.push(funcNode);
                        links.push({ source: lastCenteredNode.id, target: funcNode.id, type: 'centered' });
                        
                        // Function variables
                        let varY = curY + CONFIG.method.h + CONFIG.variable.gapY;
                        const varX = modX + CONFIG.method.w + 20;
                        
                        el.variables.forEach((varName, vIdx) => {
                            const varNode = {
                                id: `mod_${modIdx}_func_${elIdx}_var_${vIdx}`,
                                type: 'variable',
                                name: varName,
                                x: varX,
                                y: varY,
                                w: CONFIG.variable.w,
                                h: CONFIG.variable.h
                            };
                            nodes.push(varNode);
                            links.push({ source: funcNode.id, target: varNode.id, type: 'offset' });
                            varY += CONFIG.variable.h + CONFIG.variable.gapY;
                        });
                        
                        lastCenteredNode = funcNode;
                        curY = el.variables.length > 0 ? varY + CONFIG.method.gapY : curY + CONFIG.method.h + CONFIG.method.gapY;
                    }
                    else if (el.type === 'forLoop') {
                        // For Loop node
                        const loopNode = {
                            id: `mod_${modIdx}_forloop_${elIdx}`,
                            type: 'forLoop',
                            name: 'For',
                            iterator: el.iterator,
                            iterable: el.iterable,
                            body: el.body,
                            fullCondition: el.fullCondition,
                            x: modX + CONFIG.loop.offsetX,
                            y: curY,
                            w: CONFIG.loop.w,
                            h: CONFIG.loop.h
                        };
                        nodes.push(loopNode);
                        links.push({ source: lastCenteredNode.id, target: loopNode.id, type: 'offset' });

                        // Body statements
                        let bodyY = curY + CONFIG.loop.h + CONFIG.loopBody.gapY;
                        const bodyX = modX + CONFIG.loop.offsetX + CONFIG.loopBody.offsetX;

                        el.body.slice(0, 5).forEach((stmt, bIdx) => { // Limit to 5 statements
                            const bodyNode = {
                                id: `mod_${modIdx}_forloop_${elIdx}_body_${bIdx}`,
                                type: 'loopBody',
                                name: stmt.length > 25 ? stmt.substring(0, 22) + '...' : stmt,
                                fullStatement: stmt,
                                x: bodyX,
                                y: bodyY,
                                w: CONFIG.loopBody.w,
                                h: CONFIG.loopBody.h
                            };
                            nodes.push(bodyNode);
                            links.push({ source: loopNode.id, target: bodyNode.id, type: 'offset' });
                            bodyY += CONFIG.loopBody.h + CONFIG.loopBody.gapY;
                        });

                        curY = bodyY + CONFIG.loop.gapY;
                    }
                    else if (el.type === 'whileLoop') {
                        // While Loop node
                        const loopNode = {
                            id: `mod_${modIdx}_whileloop_${elIdx}`,
                            type: 'whileLoop',
                            name: 'While',
                            condition: el.condition,
                            body: el.body,
                            x: modX + CONFIG.loop.offsetX,
                            y: curY,
                            w: CONFIG.loop.w,
                            h: CONFIG.loop.h
                        };
                        nodes.push(loopNode);
                        links.push({ source: lastCenteredNode.id, target: loopNode.id, type: 'offset' });

                        // Body statements
                        let bodyY = curY + CONFIG.loop.h + CONFIG.loopBody.gapY;
                        const bodyX = modX + CONFIG.loop.offsetX + CONFIG.loopBody.offsetX;

                        el.body.slice(0, 5).forEach((stmt, bIdx) => {
                            const bodyNode = {
                                id: `mod_${modIdx}_whileloop_${elIdx}_body_${bIdx}`,
                                type: 'loopBody',
                                name: stmt.length > 25 ? stmt.substring(0, 22) + '...' : stmt,
                                fullStatement: stmt,
                                x: bodyX,
                                y: bodyY,
                                w: CONFIG.loopBody.w,
                                h: CONFIG.loopBody.h
                            };
                            nodes.push(bodyNode);
                            links.push({ source: loopNode.id, target: bodyNode.id, type: 'offset' });
                            bodyY += CONFIG.loopBody.h + CONFIG.loopBody.gapY;
                        });

                        curY = bodyY + CONFIG.loop.gapY;
                    }
                    else if (el.type === 'instantiation') {
                        const instText = `${el.variable} = ${el.className}(${el.args})`;
                        const instNode = {
                            id: `mod_${modIdx}_inst_${elIdx}`,
                            type: 'instantiation',
                            name: instText,
                            shortName: el.variable,
                            className: el.className,
                            x: modX + (CONFIG.module.w - CONFIG.instantiation.w) / 2,
                            y: curY,
                            w: CONFIG.instantiation.w,
                            h: CONFIG.instantiation.h
                        };
                        nodes.push(instNode);
                        links.push({ source: lastCenteredNode.id, target: instNode.id, type: 'centered' });
                        lastCenteredNode = instNode;
                        curY += CONFIG.instantiation.h + CONFIG.instantiation.gapY;
                    }
                });
            });

            // Node lookup
            const nodeMap = {};
            nodes.forEach(n => nodeMap[n.id] = n);

            // Draw links with rounded corners
            g.selectAll('.link')
                .data(links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('fill', 'none')
                .attr('stroke', CONFIG.colors.link)
                .attr('stroke-width', 1.5)
                .attr('marker-end', 'url(#arrowhead)')
                .attr('d', d => {
                    const source = nodeMap[d.source];
                    const target = nodeMap[d.target];
                    
                    const x1 = source.x + source.w / 2;
                    const y1 = source.y + source.h;
                    const x2 = d.type === 'centered' ? target.x + target.w / 2 : target.x;
                    const y2 = d.type === 'centered' ? target.y : target.y + target.h / 2;
                    
                    return createRoundedPath(x1, y1, x2, y2, d.type);
                });

            // Draw nodes
            const nodeGroups = g.selectAll('.node-group')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node-group node-${d.type}`)
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip);

            nodeGroups.each(function(d) {
                const node = d3.select(this);
                const colors = CONFIG.colors[d.type] || CONFIG.colors.data;

                switch(d.type) {
                    case 'project':
                        node.append('rect')
                            .attr('x', d.x).attr('y', d.y)
                            .attr('width', d.w).attr('height', d.h)
                            .attr('rx', 8)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '14px')
                            .attr('font-weight', 'bold')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'module':
                        node.append('rect')
                            .attr('x', d.x).attr('y', d.y)
                            .attr('width', d.w).attr('height', d.h)
                            .attr('rx', 5)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '12px')
                            .attr('font-weight', '600')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'class':
                        node.append('ellipse')
                            .attr('cx', d.x + d.w / 2).attr('cy', d.y + d.h / 2)
                            .attr('rx', d.w / 2).attr('ry', d.h / 2)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '11px')
                            .html(`<tspan fill="#2980b9">class </tspan><tspan fill="#333">${d.name}</tspan>`);
                        break;

                    case 'method':
                        const hx = d.x, hy = d.y, hw = d.w, hh = d.h;
                        const indent = hw * 0.12;
                        const hexPoints = [
                            [hx + indent, hy],
                            [hx + hw - indent, hy],
                            [hx + hw, hy + hh / 2],
                            [hx + hw - indent, hy + hh],
                            [hx + indent, hy + hh],
                            [hx, hy + hh / 2]
                        ];
                        node.append('polygon')
                            .attr('points', hexPoints.map(p => p.join(',')).join(' '))
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'variable':
                        node.append('rect')
                            .attr('x', d.x).attr('y', d.y)
                            .attr('width', d.w).attr('height', d.h)
                            .attr('rx', 3)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 1.5);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '9px')
                            .attr('fill', '#333')
                            .text(d.name.length > 18 ? d.name.substring(0, 15) + '...' : d.name);
                        break;

                    case 'data':
                        if (d.isDict) {
                            node.append('rect')
                                .attr('x', d.x).attr('y', d.y + 6)
                                .attr('width', d.w).attr('height', d.h - 6)
                                .attr('rx', 3)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                            node.append('ellipse')
                                .attr('cx', d.x + d.w / 2).attr('cy', d.y + 8)
                                .attr('rx', d.w / 2).attr('ry', 8)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                        } else {
                            node.append('rect')
                                .attr('x', d.x).attr('y', d.y)
                                .attr('width', d.w).attr('height', d.h)
                                .attr('rx', 4)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                        }
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2 + 3)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'forLoop':
                    case 'whileLoop':
                        // Parallelogram with details
                        const lx = d.x, ly = d.y, lw = d.w, lh = d.h;
                        const skew = 12;
                        const paraPoints = [
                            [lx + skew, ly],
                            [lx + lw, ly],
                            [lx + lw - skew, ly + lh],
                            [lx, ly + lh]
                        ];
                        node.append('polygon')
                            .attr('points', paraPoints.map(p => p.join(',')).join(' '))
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        
                        // Loop type label
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + 14)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '11px')
                            .attr('font-weight', 'bold')
                            .attr('fill', '#333')
                            .text(d.name);
                        
                        // Condition/iterator info
                        const detailText = d.type === 'forLoop' 
                            ? `${d.iterator} in ${d.iterable.substring(0, 15)}${d.iterable.length > 15 ? '...' : ''}`
                            : d.condition.substring(0, 18) + (d.condition.length > 18 ? '...' : '');
                        
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + 32)
                            .attr('text-anchor', 'middle')
                            .attr('class', 'loop-detail-text')
                            .text(detailText);
                        break;

                    case 'loopBody':
                        node.append('rect')
                            .attr('x', d.x).attr('y', d.y)
                            .attr('width', d.w).attr('height', d.h)
                            .attr('rx', 2)
                            .attr('fill', CONFIG.colors.loopBody.fill)
                            .attr('stroke', CONFIG.colors.loopBody.stroke)
                            .attr('stroke-width', 1)
                            .attr('stroke-dasharray', '3,2');
                        node.append('text')
                            .attr('x', d.x + 5).attr('y', d.y + d.h / 2)
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '9px')
                            .attr('font-family', 'Fira Code, monospace')
                            .attr('fill', '#666')
                            .text(d.name);
                        break;

                    case 'instantiation':
                        node.append('rect')
                            .attr('x', d.x).attr('y', d.y)
                            .attr('width', d.w).attr('height', d.h)
                            .attr('rx', 5)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2).attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '9px')
                            .attr('fill', '#333')
                            .text(d.name.length > 28 ? d.name.substring(0, 25) + '...' : d.name);
                        break;
                }
            });

            // Initial view
            const scale = Math.min(width / (totalWidth + 100), 1, 0.9);
            svg.call(zoom.transform, d3.zoomIdentity.translate(20, 10).scale(scale));
        }

        function showTooltip(event, d) {
            let html = `<h4>${d.name}</h4>`;
            html += `<p>Type: <code>${d.type}</code></p>`;
            
            if (d.type === 'forLoop') {
                html += `<p>Iterator: <code>${d.iterator}</code></p>`;
                html += `<p>Iterable: <code>${d.iterable}</code></p>`;
                if (d.body && d.body.length > 0) {
                    html += `<p>Body (${d.body.length} statements):</p>`;
                    html += `<div class="body-list">`;
                    d.body.forEach(stmt => {
                        html += `<div>${stmt}</div>`;
                    });
                    html += `</div>`;
                }
            }
            
            if (d.type === 'whileLoop') {
                html += `<p>Condition: <code>${d.condition}</code></p>`;
                if (d.body && d.body.length > 0) {
                    html += `<p>Body (${d.body.length} statements):</p>`;
                    html += `<div class="body-list">`;
                    d.body.forEach(stmt => {
                        html += `<div>${stmt}</div>`;
                    });
                    html += `</div>`;
                }
            }

            if (d.type === 'loopBody') {
                html = `<h4>Statement</h4>`;
                html += `<p><code>${d.fullStatement}</code></p>`;
            }

            if (d.type === 'instantiation' && d.className) {
                html += `<p>Creates: <code>${d.className}</code></p>`;
            }

            if (d.type === 'method' && d.params !== undefined) {
                html += `<p>Params: <code>${d.params || 'none'}</code></p>`;
            }

            tooltip
                .html(html)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }

        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        // =============================================
        // Controls
        // =============================================
        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().call(zoom.scaleBy, 1.3);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().call(zoom.scaleBy, 0.7);
        });

        document.getElementById('resetView').addEventListener('click', () => {
            svg.transition().call(zoom.transform, d3.zoomIdentity.translate(20, 10).scale(0.8));
        });

        document.getElementById('exportSVG').addEventListener('click', () => {
            const svgEl = document.getElementById('visualization');
            const svgData = new XMLSerializer().serializeToString(svgEl);
            const blob = new Blob([svgData], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'python_structure.svg';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Parse Button
        document.getElementById('parseBtn').addEventListener('click', () => {
            files[activeFileIndex].code = codeInput.value;
            
            const projectName = document.getElementById('projectName').value || 'Project';
            const parsedModules = files
                .filter(f => f.code.trim())
                .map(f => parsePythonCode(f.code, f.name));

            if (parsedModules.length === 0) {
                alert('Please add some Python code first!');
                return;
            }

            renderSequentialFlow(projectName, parsedModules);
        });

        // Load Example
        document.getElementById('loadExampleBtn').addEventListener('click', () => {
            files = [
                {
                    name: 'countdown.py',
                    code: `# While loop example
count = 5

while count > 0:
    print(f"Counting down: {count}")
    count = count - 1

print("Blast off!")`
                },
                {
                    name: 'triangle.py',
                    code: `def user_input():
    height = int(input("Enter height of the star triangle:\\n"))
    return height

height = user_input()

blanks = height
stars = 0

for loops in range(height):
    blanks -= 1
    stars += 1
    print(" " * blanks + "*" * stars)`
                }
            ];

            activeFileIndex = 0;
            codeInput.value = files[0].code;
            document.getElementById('projectName').value = 'Loop Examples';
            renderFileTabs();
        });

        // Initialize
        renderFileTabs();
        initVisualization();
    </script>
</body>
</html>

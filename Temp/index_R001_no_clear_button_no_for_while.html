<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python OOP Structure Visualizer - Sequential Flow</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #f5f5f5;
            color: #333;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Left Panel - Code Input */
        .input-panel {
            width: 380px;
            background: #fff;
            padding: 20px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .input-panel h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .file-tab {
            padding: 6px 12px;
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            color: #7f8c8d;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .file-tab:hover {
            background: #d5dbdb;
        }

        .file-tab.active {
            background: #3498db;
            border-color: #2980b9;
            color: white;
        }

        .file-tab .remove {
            margin-left: 6px;
            opacity: 0.6;
        }

        .file-tab .remove:hover {
            opacity: 1;
        }

        .add-file-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px dashed #bdc3c7;
            color: #95a5a6;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .add-file-btn:hover {
            border-color: #3498db;
            color: #3498db;
        }

        .project-name-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .project-name-input {
            flex: 1;
            padding: 8px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #2c3e50;
            font-weight: 600;
        }

        .project-name-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .code-input {
            flex: 1;
            background: #2c3e50;
            border: 1px solid #34495e;
            border-radius: 6px;
            padding: 12px;
            color: #ecf0f1;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            resize: none;
            line-height: 1.5;
        }

        .code-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .parse-btn {
            flex: 1;
            padding: 10px 16px;
            background: #27ae60;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .parse-btn:hover {
            background: #219a52;
        }

        .load-example-btn {
            padding: 10px 16px;
            background: #ecf0f1;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            color: #7f8c8d;
            cursor: pointer;
            transition: all 0.2s;
        }

        .load-example-btn:hover {
            background: #d5dbdb;
            color: #2c3e50;
        }

        /* Right Panel - Visualization */
        .viz-panel {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #fff;
            background-image: 
                linear-gradient(rgba(0,0,0,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .viz-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .viz-controls button {
            padding: 6px 12px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            color: #666;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .viz-controls button:hover {
            background: #f8f9fa;
            border-color: #3498db;
            color: #3498db;
        }

        #visualization {
            width: 100%;
            height: 100%;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(255,255,255,0.95);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .legend h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 0.75rem;
            color: #666;
        }

        .legend-shape {
            width: 20px;
            height: 14px;
            border-radius: 2px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            border-radius: 6px;
            padding: 10px 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 280px;
            z-index: 1000;
            color: #ecf0f1;
        }

        .tooltip h4 {
            color: #3498db;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .tooltip p {
            font-size: 0.8rem;
            margin: 2px 0;
        }

        .tooltip code {
            background: rgba(0,0,0,0.3);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
        }

        .instructions {
            margin-top: 12px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #7f8c8d;
            line-height: 1.5;
        }

        .instructions strong {
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-panel">
            <h2>üêç Python Structure Visualizer</h2>
            
            <div class="project-name-row">
                <input type="text" class="project-name-input" id="projectName" placeholder="Project Name" value="Quiz Project">
            </div>
            
            <div class="file-tabs" id="fileTabs">
                <button class="file-tab active" data-file="0">data.py</button>
                <button class="add-file-btn" id="addFileBtn">+ Add</button>
            </div>
            
            <textarea class="code-input" id="codeInput" placeholder="Paste your Python code here..."></textarea>
            
            <div class="btn-row">
                <button class="parse-btn" id="parseBtn">‚ñ∂ Generate Diagram</button>
                <button class="load-example-btn" id="loadExampleBtn">Load Example</button>
            </div>
            
            <div class="instructions">
                <strong>Sequential Flow Layout:</strong><br>
                ‚Ä¢ Modules as vertical columns<br>
                ‚Ä¢ Elements flow top-to-bottom in code order<br>
                ‚Ä¢ Methods/variables branch to the right
            </div>
        </div>
        
        <div class="viz-panel">
            <div class="viz-controls">
                <button id="zoomIn">+</button>
                <button id="zoomOut">‚àí</button>
                <button id="resetView">Reset</button>
                <button id="exportSVG">Export SVG</button>
            </div>
            
            <svg id="visualization"></svg>
            
            <div class="legend">
                <h4>Legend</h4>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #dae8fc; border: 1px solid #6c8ebf;"></div>
                    <span>Project</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #fff2cc; border: 1px solid #d6b656;"></div>
                    <span>Module</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #d5e8d4; border: 1px solid #82b366; border-radius: 50%;"></div>
                    <span>Class</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #f8cecc; border: 1px solid #b85450;"></div>
                    <span>Method</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #e1d5e7; border: 1px solid #9673a6;"></div>
                    <span>Variable</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #f5f5f5; border: 1px solid #666;"></div>
                    <span>Data / List</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape" style="background: #fff2cc; border: 1px solid #d6b656;"></div>
                    <span>Loop / Instantiation</span>
                </div>
            </div>
            
            <div class="tooltip" id="tooltip"></div>
        </div>
    </div>

    <script>
        // =============================================
        // Configuration - Matching draw.io style
        // =============================================
        const CONFIG = {
            // Project block
            project: { w: 160, h: 45 },
            
            // Module blocks
            module: { w: 140, h: 35, gapX: 280 },
            
            // Class blocks (ellipse)
            class: { w: 140, h: 45 },
            
            // Method blocks (hexagon)
            method: { w: 130, h: 35, offsetX: 100, gapY: 15 },
            
            // Variable blocks
            variable: { w: 120, h: 24, offsetX: 90, gapY: 8 },
            
            // Data blocks
            data: { w: 110, h: 40, gapY: 15 },
            
            // Loop blocks
            loop: { w: 100, h: 35, offsetX: 120, gapY: 15 },
            
            // Instantiation blocks
            instantiation: { w: 180, h: 30, gapY: 15 },
            
            // Vertical spacing
            verticalGap: 20,
            moduleStartY: 120,
            
            // Colors matching draw.io
            colors: {
                project: { fill: '#dae8fc', stroke: '#6c8ebf' },
                module: { fill: '#fff2cc', stroke: '#d6b656' },
                class: { fill: '#d5e8d4', stroke: '#82b366' },
                method: { fill: '#f8cecc', stroke: '#b85450' },
                variable: { fill: '#e1d5e7', stroke: '#9673a6' },
                data: { fill: '#f5f5f5', stroke: '#666666' },
                loop: { fill: '#fff2cc', stroke: '#d6b656' },
                instantiation: { fill: '#fff2cc', stroke: '#d6b656' },
                link: '#666'
            }
        };

        // =============================================
        // File Management
        // =============================================
        const files = [
            { name: 'data.py', code: '' },
            { name: 'question_model.py', code: '' },
            { name: 'quiz_brain.py', code: '' },
            { name: 'main.py', code: '' }
        ];
        let activeFileIndex = 0;

        const fileTabs = document.getElementById('fileTabs');
        const codeInput = document.getElementById('codeInput');
        const addFileBtn = document.getElementById('addFileBtn');

        function renderFileTabs() {
            fileTabs.innerHTML = '';
            files.forEach((file, index) => {
                const tab = document.createElement('button');
                tab.className = `file-tab ${index === activeFileIndex ? 'active' : ''}`;
                tab.dataset.file = index;
                tab.innerHTML = `${file.name}${files.length > 1 ? `<span class="remove" data-remove="${index}">√ó</span>` : ''}`;
                fileTabs.appendChild(tab);
            });
            fileTabs.appendChild(addFileBtn);
        }

        fileTabs.addEventListener('click', (e) => {
            if (e.target.dataset.file !== undefined) {
                files[activeFileIndex].code = codeInput.value;
                activeFileIndex = parseInt(e.target.dataset.file);
                codeInput.value = files[activeFileIndex].code;
                renderFileTabs();
            } else if (e.target.dataset.remove !== undefined) {
                e.stopPropagation();
                const removeIndex = parseInt(e.target.dataset.remove);
                if (files.length > 1) {
                    files.splice(removeIndex, 1);
                    if (activeFileIndex >= files.length) activeFileIndex = files.length - 1;
                    codeInput.value = files[activeFileIndex].code;
                    renderFileTabs();
                }
            }
        });

        addFileBtn.addEventListener('click', () => {
            files[activeFileIndex].code = codeInput.value;
            const newName = prompt('Enter file name (e.g., utils.py):', 'new_file.py');
            if (newName) {
                files.push({ name: newName, code: '' });
                activeFileIndex = files.length - 1;
                codeInput.value = '';
                renderFileTabs();
            }
        });

        // =============================================
        // Python Parser
        // =============================================
        function parsePythonCode(code, moduleName) {
            const result = {
                name: moduleName,
                elements: [] // Sequential list of elements in code order
            };

            const lines = code.split('\n');
            let currentClass = null;
            let currentMethod = null;
            let classIndent = -1;
            let methodIndent = -1;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const indent = line.search(/\S/);
                if (indent === -1) continue; // Empty line

                // Skip comments
                if (trimmed.startsWith('#')) continue;

                // Check if we've exited a class
                if (currentClass && indent <= classIndent && trimmed && !trimmed.startsWith('#')) {
                    currentClass = null;
                    currentMethod = null;
                    classIndent = -1;
                    methodIndent = -1;
                }

                // Check if we've exited a method
                if (currentMethod && indent <= methodIndent && trimmed && !trimmed.startsWith('def ')) {
                    currentMethod = null;
                    methodIndent = -1;
                }

                // Parse imports (skip for visualization)
                if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {
                    continue;
                }

                // Parse class definitions
                const classMatch = trimmed.match(/^class\s+(\w+)(?:\(.*\))?:/);
                if (classMatch) {
                    currentClass = {
                        type: 'class',
                        name: classMatch[1],
                        methods: []
                    };
                    result.elements.push(currentClass);
                    classIndent = indent;
                    currentMethod = null;
                    methodIndent = -1;
                    continue;
                }

                // Parse method definitions (inside class)
                if (currentClass) {
                    const methodMatch = trimmed.match(/^def\s+(\w+)\s*\(/);
                    if (methodMatch) {
                        currentMethod = {
                            type: 'method',
                            name: methodMatch[1],
                            variables: []
                        };
                        currentClass.methods.push(currentMethod);
                        methodIndent = indent;
                        continue;
                    }

                    // Parse self.x assignments in __init__
                    if (currentMethod) {
                        const selfMatch = trimmed.match(/self\.(\w+)\s*=/);
                        if (selfMatch) {
                            const varName = currentMethod.name === '__init__' 
                                ? `self.${selfMatch[1]}` 
                                : `self.${selfMatch[1]}`;
                            if (!currentMethod.variables.includes(varName)) {
                                currentMethod.variables.push(varName);
                            }
                            continue;
                        }

                        // Parse local variables
                        const varMatch = trimmed.match(/^(\w+)\s*=\s*(?!.*def\s)/);
                        if (varMatch && !['self', '_', 'True', 'False', 'None'].includes(varMatch[1])) {
                            if (!currentMethod.variables.includes(varMatch[1])) {
                                currentMethod.variables.push(varMatch[1]);
                            }
                        }
                    }
                    continue;
                }

                // Parse standalone data structures at module level
                const dictMatch = trimmed.match(/^(\w+)\s*=\s*[\[{]/);
                if (dictMatch) {
                    result.elements.push({
                        type: 'data',
                        name: dictMatch[1],
                        isDict: trimmed.includes('{') || trimmed.includes('dict(')
                    });
                    continue;
                }

                // Parse list comprehensions or empty lists that become populated
                const listMatch = trimmed.match(/^(\w+)\s*=\s*\[\]/);
                if (listMatch) {
                    result.elements.push({
                        type: 'data',
                        name: listMatch[1],
                        isDict: false
                    });
                    continue;
                }

                // Parse loops at module level
                if (trimmed.startsWith('for ')) {
                    const forMatch = trimmed.match(/^for\s+(.+?)\s+in\s+(.+?):/);
                    result.elements.push({
                        type: 'loop',
                        loopType: 'For',
                        condition: forMatch ? `${forMatch[1]} in ${forMatch[2]}` : trimmed
                    });
                    continue;
                }

                if (trimmed.startsWith('while ')) {
                    const whileMatch = trimmed.match(/^while\s+(.+?):/);
                    result.elements.push({
                        type: 'loop',
                        loopType: 'While',
                        condition: whileMatch ? whileMatch[1] : trimmed
                    });
                    continue;
                }

                // Parse instantiations at module level
                const instMatch = trimmed.match(/^(\w+)\s*=\s*(\w+)\s*\((.*)?\)/);
                if (instMatch && !currentClass) {
                    const className = instMatch[2];
                    // Check if it looks like a class instantiation (capitalized)
                    if (className[0] === className[0].toUpperCase() && className[0] !== className[0].toLowerCase()) {
                        result.elements.push({
                            type: 'instantiation',
                            variable: instMatch[1],
                            className: className,
                            args: instMatch[3] || ''
                        });
                        continue;
                    }
                }

                // Parse standalone function definitions at module level
                const funcMatch = trimmed.match(/^def\s+(\w+)\s*\(/);
                if (funcMatch && !currentClass) {
                    result.elements.push({
                        type: 'function',
                        name: funcMatch[1]
                    });
                    continue;
                }
            }

            return result;
        }

        // =============================================
        // D3 Visualization - Sequential Flow Layout
        // =============================================
        const svg = d3.select('#visualization');
        const tooltip = d3.select('#tooltip');
        let g;
        let zoom;

        function initVisualization() {
            const width = svg.node().parentElement.clientWidth;
            const height = svg.node().parentElement.clientHeight;

            svg.attr('width', width).attr('height', height);
            svg.selectAll('*').remove();

            // Add defs for markers and filters
            const defs = svg.append('defs');
            
            // Arrow marker
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '-0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 5)
                .attr('markerHeight', 5)
                .append('path')
                .attr('d', 'M 0,-4 L 8,0 L 0,4')
                .attr('fill', CONFIG.colors.link);

            g = svg.append('g');

            zoom = d3.zoom()
                .scaleExtent([0.2, 3])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);
        }

        function renderSequentialFlow(projectName, modules) {
            initVisualization();

            const width = svg.node().parentElement.clientWidth;
            const nodes = [];
            const links = [];

            // Calculate column widths based on content
            const columnWidths = [];
            modules.forEach((mod, idx) => {
                let maxWidth = CONFIG.module.w;
                mod.elements.forEach(el => {
                    if (el.type === 'class') {
                        // Class + methods + variables width
                        const methodWidth = CONFIG.method.offsetX + CONFIG.method.w;
                        const varWidth = CONFIG.method.offsetX + CONFIG.variable.offsetX + CONFIG.variable.w;
                        maxWidth = Math.max(maxWidth, varWidth + 40);
                    }
                    if (el.type === 'loop') {
                        maxWidth = Math.max(maxWidth, CONFIG.loop.offsetX + CONFIG.loop.w + 20);
                    }
                    if (el.type === 'instantiation') {
                        maxWidth = Math.max(maxWidth, CONFIG.instantiation.w + 20);
                    }
                });
                columnWidths.push(maxWidth);
            });

            // Calculate column X positions
            const columnX = [];
            let currentX = 60;
            columnWidths.forEach((w, i) => {
                columnX.push(currentX);
                currentX += w + 40;
            });
            const totalWidth = currentX;

            // Create project node
            const projectNode = {
                id: 'project',
                type: 'project',
                name: projectName,
                x: 60 + (totalWidth - 60) / 2,
                y: 30,
                w: CONFIG.project.w,
                h: CONFIG.project.h
            };
            nodes.push(projectNode);

            // Process each module
            modules.forEach((mod, modIdx) => {
                const modX = columnX[modIdx];
                let curY = CONFIG.moduleStartY;

                // Module node
                const moduleNode = {
                    id: `mod_${modIdx}`,
                    type: 'module',
                    name: mod.name.replace('.py', ''),
                    x: modX,
                    y: curY,
                    w: CONFIG.module.w,
                    h: CONFIG.module.h
                };
                nodes.push(moduleNode);
                links.push({ source: projectNode.id, target: moduleNode.id, type: 'centered' });

                curY += CONFIG.module.h + CONFIG.verticalGap;
                let lastCenteredNode = moduleNode;

                // Process elements in sequence
                mod.elements.forEach((el, elIdx) => {
                    if (el.type === 'data') {
                        const dataNode = {
                            id: `mod_${modIdx}_data_${elIdx}`,
                            type: 'data',
                            name: el.name,
                            x: modX + (CONFIG.module.w - CONFIG.data.w) / 2,
                            y: curY,
                            w: CONFIG.data.w,
                            h: CONFIG.data.h,
                            isDict: el.isDict
                        };
                        nodes.push(dataNode);
                        links.push({ source: lastCenteredNode.id, target: dataNode.id, type: 'centered' });
                        lastCenteredNode = dataNode;
                        curY += CONFIG.data.h + CONFIG.data.gapY;
                    }
                    else if (el.type === 'class') {
                        // Class node (centered under module)
                        const classNode = {
                            id: `mod_${modIdx}_class_${elIdx}`,
                            type: 'class',
                            name: el.name,
                            x: modX + (CONFIG.module.w - CONFIG.class.w) / 2,
                            y: curY,
                            w: CONFIG.class.w,
                            h: CONFIG.class.h
                        };
                        nodes.push(classNode);
                        links.push({ source: lastCenteredNode.id, target: classNode.id, type: 'centered' });

                        // Methods (offset to the right)
                        let methodY = curY + CONFIG.class.h + CONFIG.method.gapY;
                        const methodX = modX + CONFIG.method.offsetX;

                        el.methods.forEach((method, mIdx) => {
                            const methodNode = {
                                id: `mod_${modIdx}_class_${elIdx}_method_${mIdx}`,
                                type: 'method',
                                name: method.name,
                                x: methodX,
                                y: methodY,
                                w: CONFIG.method.w,
                                h: CONFIG.method.h
                            };
                            nodes.push(methodNode);
                            links.push({ source: classNode.id, target: methodNode.id, type: 'offset' });

                            // Variables (offset further right)
                            let varY = methodY + CONFIG.method.h + CONFIG.variable.gapY;
                            const varX = methodX + CONFIG.variable.offsetX;

                            method.variables.forEach((varName, vIdx) => {
                                const varNode = {
                                    id: `mod_${modIdx}_class_${elIdx}_method_${mIdx}_var_${vIdx}`,
                                    type: 'variable',
                                    name: varName,
                                    x: varX,
                                    y: varY,
                                    w: CONFIG.variable.w,
                                    h: CONFIG.variable.h
                                };
                                nodes.push(varNode);
                                links.push({ source: methodNode.id, target: varNode.id, type: 'offset' });
                                varY += CONFIG.variable.h + CONFIG.variable.gapY;
                            });

                            // Update methodY for next method
                            if (method.variables.length > 0) {
                                methodY = varY + CONFIG.method.gapY;
                            } else {
                                methodY += CONFIG.method.h + CONFIG.method.gapY + 20;
                            }
                        });

                        curY = methodY + 10;
                        lastCenteredNode = classNode;
                    }
                    else if (el.type === 'loop') {
                        // Loop node (offset to the right from last centered)
                        const loopNode = {
                            id: `mod_${modIdx}_loop_${elIdx}`,
                            type: 'loop',
                            name: el.loopType,
                            condition: el.condition,
                            x: modX + CONFIG.loop.offsetX,
                            y: curY,
                            w: CONFIG.loop.w,
                            h: CONFIG.loop.h
                        };
                        nodes.push(loopNode);
                        links.push({ source: lastCenteredNode.id, target: loopNode.id, type: 'offset' });
                        curY += CONFIG.loop.h + CONFIG.loop.gapY;
                    }
                    else if (el.type === 'instantiation') {
                        // Instantiation node (centered)
                        const instText = `${el.variable} = ${el.className}(${el.args})`;
                        const instNode = {
                            id: `mod_${modIdx}_inst_${elIdx}`,
                            type: 'instantiation',
                            name: instText,
                            shortName: el.variable,
                            className: el.className,
                            x: modX + (CONFIG.module.w - CONFIG.instantiation.w) / 2,
                            y: curY,
                            w: CONFIG.instantiation.w,
                            h: CONFIG.instantiation.h
                        };
                        nodes.push(instNode);
                        links.push({ source: lastCenteredNode.id, target: instNode.id, type: 'centered' });
                        lastCenteredNode = instNode;
                        curY += CONFIG.instantiation.h + CONFIG.instantiation.gapY;
                    }
                    else if (el.type === 'function') {
                        // Standalone function (centered)
                        const funcNode = {
                            id: `mod_${modIdx}_func_${elIdx}`,
                            type: 'method',
                            name: el.name,
                            x: modX + (CONFIG.module.w - CONFIG.method.w) / 2,
                            y: curY,
                            w: CONFIG.method.w,
                            h: CONFIG.method.h
                        };
                        nodes.push(funcNode);
                        links.push({ source: lastCenteredNode.id, target: funcNode.id, type: 'centered' });
                        lastCenteredNode = funcNode;
                        curY += CONFIG.method.h + CONFIG.method.gapY;
                    }
                });
            });

            // Create node lookup
            const nodeMap = {};
            nodes.forEach(n => nodeMap[n.id] = n);

            // Draw links
            const linkElements = g.selectAll('.link')
                .data(links)
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('fill', 'none')
                .attr('stroke', CONFIG.colors.link)
                .attr('stroke-width', 1.5)
                .attr('marker-end', 'url(#arrowhead)')
                .attr('d', d => {
                    const source = nodeMap[d.source];
                    const target = nodeMap[d.target];
                    
                    if (d.type === 'centered') {
                        // Straight down
                        const x1 = source.x + source.w / 2;
                        const y1 = source.y + source.h;
                        const x2 = target.x + target.w / 2;
                        const y2 = target.y;
                        
                        return `M ${x1} ${y1} L ${x1} ${(y1 + y2) / 2} L ${x2} ${(y1 + y2) / 2} L ${x2} ${y2}`;
                    } else {
                        // Offset - exit bottom, enter left
                        const x1 = source.x + source.w / 2;
                        const y1 = source.y + source.h;
                        const x2 = target.x;
                        const y2 = target.y + target.h / 2;
                        
                        const midY = y1 + 10;
                        const midX = x2 - 15;
                        
                        return `M ${x1} ${y1} L ${x1} ${midY} L ${midX} ${midY} L ${midX} ${y2} L ${x2} ${y2}`;
                    }
                });

            // Draw nodes
            const nodeGroups = g.selectAll('.node-group')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node-group node-${d.type}`)
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip);

            nodeGroups.each(function(d) {
                const node = d3.select(this);
                const colors = CONFIG.colors[d.type] || CONFIG.colors.data;

                switch(d.type) {
                    case 'project':
                        node.append('rect')
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', d.w)
                            .attr('height', d.h)
                            .attr('rx', 8)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '16px')
                            .attr('font-weight', 'bold')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'module':
                        node.append('rect')
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', d.w)
                            .attr('height', d.h)
                            .attr('rx', 5)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '13px')
                            .attr('font-weight', '600')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'class':
                        node.append('ellipse')
                            .attr('cx', d.x + d.w / 2)
                            .attr('cy', d.y + d.h / 2)
                            .attr('rx', d.w / 2)
                            .attr('ry', d.h / 2)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        // "class" keyword in blue
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '12px')
                            .html(`<tspan fill="blue">class </tspan><tspan fill="#333">${d.name}</tspan>`);
                        break;

                    case 'method':
                        // Hexagon shape
                        const hx = d.x, hy = d.y, hw = d.w, hh = d.h;
                        const indent = hw * 0.15;
                        const hexPoints = [
                            [hx + indent, hy],
                            [hx + hw - indent, hy],
                            [hx + hw, hy + hh / 2],
                            [hx + hw - indent, hy + hh],
                            [hx + indent, hy + hh],
                            [hx, hy + hh / 2]
                        ];
                        node.append('polygon')
                            .attr('points', hexPoints.map(p => p.join(',')).join(' '))
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '11px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'variable':
                        node.append('rect')
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', d.w)
                            .attr('height', d.h)
                            .attr('rx', 2)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 1.5);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'data':
                        // Cylinder-like shape for dicts, rectangle for lists
                        if (d.isDict) {
                            // Simplified cylinder
                            node.append('rect')
                                .attr('x', d.x)
                                .attr('y', d.y + 5)
                                .attr('width', d.w)
                                .attr('height', d.h - 5)
                                .attr('rx', 3)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                            node.append('ellipse')
                                .attr('cx', d.x + d.w / 2)
                                .attr('cy', d.y + 8)
                                .attr('rx', d.w / 2)
                                .attr('ry', 8)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                        } else {
                            node.append('rect')
                                .attr('x', d.x)
                                .attr('y', d.y)
                                .attr('width', d.w)
                                .attr('height', d.h)
                                .attr('rx', 4)
                                .attr('fill', colors.fill)
                                .attr('stroke', colors.stroke)
                                .attr('stroke-width', 1.5);
                        }
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2 + 3)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '11px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'loop':
                        // Parallelogram
                        const lx = d.x, ly = d.y, lw = d.w, lh = d.h;
                        const skew = 12;
                        const paraPoints = [
                            [lx + skew, ly],
                            [lx + lw, ly],
                            [lx + lw - skew, ly + lh],
                            [lx, ly + lh]
                        ];
                        node.append('polygon')
                            .attr('points', paraPoints.map(p => p.join(',')).join(' '))
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '12px')
                            .attr('font-weight', '600')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;

                    case 'instantiation':
                        node.append('rect')
                            .attr('x', d.x)
                            .attr('y', d.y)
                            .attr('width', d.w)
                            .attr('height', d.h)
                            .attr('rx', 5)
                            .attr('fill', colors.fill)
                            .attr('stroke', colors.stroke)
                            .attr('stroke-width', 2);
                        node.append('text')
                            .attr('x', d.x + d.w / 2)
                            .attr('y', d.y + d.h / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .attr('font-size', '10px')
                            .attr('fill', '#333')
                            .text(d.name);
                        break;
                }
            });

            // Initial view transform
            const scale = Math.min(width / (totalWidth + 100), 1);
            svg.call(zoom.transform, d3.zoomIdentity.translate(20, 10).scale(scale));
        }

        function showTooltip(event, d) {
            let html = `<h4>${d.name}</h4>`;
            html += `<p>Type: <code>${d.type}</code></p>`;
            
            if (d.type === 'instantiation' && d.className) {
                html += `<p>Creates: <code>${d.className}</code></p>`;
            }
            if (d.type === 'loop' && d.condition) {
                html += `<p>Condition: <code>${d.condition}</code></p>`;
            }

            tooltip
                .html(html)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }

        function hideTooltip() {
            tooltip.style('opacity', 0);
        }

        // =============================================
        // Controls
        // =============================================
        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().call(zoom.scaleBy, 1.3);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().call(zoom.scaleBy, 0.7);
        });

        document.getElementById('resetView').addEventListener('click', () => {
            const width = svg.node().parentElement.clientWidth;
            svg.transition().call(zoom.transform, d3.zoomIdentity.translate(20, 10).scale(0.8));
        });

        document.getElementById('exportSVG').addEventListener('click', () => {
            const svgEl = document.getElementById('visualization');
            const svgData = new XMLSerializer().serializeToString(svgEl);
            const blob = new Blob([svgData], {type: 'image/svg+xml'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'python_structure.svg';
            a.click();
            URL.revokeObjectURL(url);
        });

        // =============================================
        // Parse Button
        // =============================================
        document.getElementById('parseBtn').addEventListener('click', () => {
            files[activeFileIndex].code = codeInput.value;
            
            const projectName = document.getElementById('projectName').value || 'Project';
            const parsedModules = files
                .filter(f => f.code.trim())
                .map(f => parsePythonCode(f.code, f.name));

            if (parsedModules.length === 0) {
                alert('Please add some Python code first!');
                return;
            }

            renderSequentialFlow(projectName, parsedModules);
        });

        // =============================================
        // Load Example
        // =============================================
        document.getElementById('loadExampleBtn').addEventListener('click', () => {
            files.length = 0;
            files.push(
                {
                    name: 'data.py',
                    code: `# Question data for the quiz
question_data = [
    {"text": "A slug's blood is green.", "answer": "True"},
    {"text": "The longest war lasted 335 years.", "answer": "True"},
    {"text": "Pigs can look up into the sky.", "answer": "False"},
]`
                },
                {
                    name: 'question_model.py',
                    code: `class Question:
    def __init__(self, q_text, q_answer):
        self.text = q_text
        self.answer = q_answer`
                },
                {
                    name: 'quiz_brain.py',
                    code: `class QuizBrain:
    def __init__(self, q_list):
        self.question_number = 0
        self.question_list = q_list
        self.score = 0
    
    def still_has_questions(self):
        return self.question_number < len(self.question_list)
    
    def next_question(self):
        current_question = self.question_list[self.question_number]
        self.question_number += 1
        user_answer = input(f"Q.{self.question_number}: {current_question.text} (True/False): ")
        self.check_answer(user_answer, current_question.answer)
    
    def check_answer(self, user_answer, correct_answer):
        if user_answer.lower() == correct_answer.lower():
            self.score += 1
            print("You got it right!")
        else:
            print("That's wrong.")`
                },
                {
                    name: 'main.py',
                    code: `from data import question_data
from question_model import Question
from quiz_brain import QuizBrain

question_bank = []

for item in question_data:
    question = Question(item["text"], item["answer"])
    question_bank.append(question)

quiz = QuizBrain(question_bank)

while quiz.still_has_questions():
    quiz.next_question()

print(f"Your final score: {quiz.score}/{quiz.question_number}")`
                }
            );

            activeFileIndex = 0;
            codeInput.value = files[0].code;
            document.getElementById('projectName').value = 'Quiz Project';
            renderFileTabs();
        });

        // =============================================
        // Initialize
        // =============================================
        renderFileTabs();
        initVisualization();

        // Auto-load example on start
        document.getElementById('loadExampleBtn').click();
        setTimeout(() => {
            document.getElementById('parseBtn').click();
        }, 100);
    </script>
</body>
</html>
